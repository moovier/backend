import tensorflow as tffrom keras import layers, optimizersimport kerasimport optunafrom .model import train_recommender, metrics, lossesdef optuna_study(    ratings,    patience,    num_trials,    validation_split,):    trial = lambda t: optuna_model_trial(        x=[ratings.user.values, ratings.movie.values],        y=ratings.rating.values,        patience=patience,        num_users=ratings.user.nunique(),        num_movies=ratings.movie.nunique(),        trial=t,        validation_split=validation_split,    )    study = optuna.create_study(direction="minimize")    study.optimize(func=trial, n_trials=num_trials)    return optuna_model_fit(        x=[ratings.user.values, ratings.movie.values],        y=ratings.rating.values,        patience=patience,        num_users=ratings.user.nunique(),        num_movies=ratings.movie.nunique(),        embedding_size=study.best_trial.params["embedding_size"],        learning_rate=study.best_trial.params["learning_rate"],        loss=study.best_trial.params["loss"],        validation_split=validation_split,    )def optuna_model_trial(    x,    y,    patience,    num_users,    num_movies,    trial,    validation_split):    embedding_size = trial.suggest_int("embedding_size", 1, 100)    learning_rate = trial.suggest_float("learning_rate", 1e-5, 1e-1)    loss = trial.suggest_categorical("loss", ["mean_squared_error", "mean_absolute_error"])    model = optuna_model_fit(        x=x,        y=y,        patience=patience,        num_users=num_users,        num_movies=num_movies,        embedding_size=embedding_size,        loss=loss,        learning_rate=learning_rate,        validation_split=validation_split,    )    return model.evaluate(x, y, verbose=0, return_dict=True).get("loss")def optuna_model_fit(    x,    y,    patience,    num_users,    num_movies,    embedding_size,    learning_rate,    loss,    validation_split,):    user_input = layers.Input(shape=(1,), name="user_input", dtype=tf.int32)    movie_input = layers.Input(shape=(1,), name="movie_input", dtype=tf.int32)    user_embedding = layers.Embedding(        input_dim=num_users,        output_dim=embedding_size,        embeddings_initializer="he_normal",        embeddings_regularizer=keras.regularizers.l2(1e-6),    )(user_input)    movie_embedding = layers.Embedding(        input_dim=num_movies,        output_dim=embedding_size,        embeddings_initializer="he_normal",        embeddings_regularizer=keras.regularizers.l2(1e-6),    )(movie_input)    user_bias = layers.Embedding(input_dim=num_users, output_dim=1)(user_input)    movie_bias = layers.Embedding(input_dim=num_movies, output_dim=1)(movie_input)    e = layers.Dot(axes=-1)([user_embedding, movie_embedding])    e = layers.Add()([e, user_bias, movie_bias])    e = layers.Dense(units=1, activation="relu", name="rating_prediction")(e)    model = keras.Model(inputs=[user_input, movie_input], outputs=e, name='recommender-net')    model.compile(        loss=loss,        metrics=metrics,        optimizer=optimizers.RMSprop(learning_rate),    )    return train_recommender(        x=x,        y=y,        model=model,        patience=patience,        validation_split=validation_split,    )